{"version":3,"file":"react-query-hydration.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../src/hydration/hydration.ts","../src/react/QueryClientProvider.tsx","../src/hydration/react.tsx"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { QueryClient } from '../core/queryClient'\nimport type { Query, QueryState } from '../core/query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from '../core/types'\nimport type { Mutation, MutationState } from '../core/mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options?: DehydrateOptions\n): DehydratedState {\n  options = options || {}\n\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options?.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options?.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import React from 'react'\n\nimport { QueryClient } from '../core'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nconst defaultContext = React.createContext<QueryClient | undefined>(undefined)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(contextSharing: boolean) {\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = () => {\n  const queryClient = React.useContext(\n    getQueryClientContext(React.useContext(QueryClientSharingContext))\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\nexport interface QueryClientProviderProps {\n  client: QueryClient\n  contextSharing?: boolean\n}\n\nexport const QueryClientProvider: React.FC<QueryClientProviderProps> = ({\n  client,\n  contextSharing = false,\n  children,\n}) => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useQueryClient } from '../react'\nimport { hydrate, HydrateOptions } from './hydration'\n\nexport function useHydrate(state: unknown, options?: HydrateOptions) {\n  const queryClient = useQueryClient()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({\n  children,\n  options,\n  state,\n}) => {\n  useHydrate(state, options)\n  return children as React.ReactElement<any>\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","hydrate","client","dehydratedState","options","mutationCache","getMutationCache","queryCache","getQueryCache","mutations","queries","forEach","dehydratedMutation","build","defaultOptions","_options$defaultOptio","mutationKey","dehydratedQuery","get","queryHash","dataUpdatedAt","setState","_options$defaultOptio2","queryKey","defaultContext","createContext","undefined","QueryClientSharingContext","React","useQueryClient","queryClient","useContext","window","ReactQueryClientContext","Error","useHydrate","optionsRef","useRef","current","useMemo","children","dehydrateMutations","shouldDehydrateMutation","getAll","push","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery"],"mappings":"oPAAe,SAASA,WACtBA,EAAWC,OAAOC,QAAU,SAAUC,OAC/B,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,KACrCG,EAASF,UAAUD,OAElB,IAAII,KAAOD,EACVN,OAAOQ,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,WAKpBL,IAGOS,MAAMC,KAAMR,WCoD9B,SAASS,EAA+BC,UAC/BA,EAASC,MAAMC,SAGxB,SAASC,EAA4BC,SACL,YAAvBA,EAAMH,MAAMI,OA2Cd,SAASC,EACdC,EACAC,EACAC,MAE+B,iBAApBD,GAAoD,OAApBA,OAIrCE,EAAgBH,EAAOI,mBACvBC,EAAaL,EAAOM,gBAEpBC,EAAaN,EAAoCM,WAAa,GAC9DC,EAAWP,EAAoCO,SAAW,GAEhED,EAAUE,SAAQ,SAAAC,SAChBP,EAAcQ,MACZX,aAEKE,YAAAA,EAASU,uBAATC,EAAyBN,WAC5BO,YAAaJ,EAAmBI,cAElCJ,EAAmBhB,UAIvBc,EAAQC,SAAQ,SAAAM,SACRlB,EAAQQ,EAAWW,IAAID,EAAgBE,WAGzCpB,EACEA,EAAMH,MAAMwB,cAAgBH,EAAgBrB,MAAMwB,eACpDrB,EAAMsB,SAASJ,EAAgBrB,OAMnCW,EAAWM,MACTX,aAEKE,YAAAA,EAASU,uBAATQ,EAAyBZ,SAC5Ba,SAAUN,EAAgBM,SAC1BJ,UAAWF,EAAgBE,YAE7BF,EAAgBrB,WCtJtB,IAAM4B,uEAAuBC,mBAAuCC,GAC9DC,EAA4BC,EAAMH,eAAuB,GAoBxD,IAAMI,EAAiB,eACtBC,EAAcF,EAAMG,WACFH,EAAMG,WAAWJ,IAbD,oBAAXK,QACtBA,OAAOC,0BACVD,OAAOC,wBAA0BT,GAG5BQ,OAAOC,yBAGTT,OAQFM,QACG,IAAII,MAAM,iEAGXJ,GCnCF,SAASK,EAAWvC,EAAgBQ,OACnC0B,EAAcD,IAEdO,EAAaR,EAAMS,OAAOjC,GAChCgC,EAAWE,QAAUlC,EAMrBwB,EAAMW,SAAQ,WACR3C,GACFK,EAAQ6B,EAAalC,EAAOwC,EAAWE,WAExC,CAACR,EAAalC,cAQ4B,gBAC7C4C,IAAAA,SACApC,IAAAA,eAGA+B,IAFAvC,MAEkBQ,GACXoC,eF0CF,SACLtC,EACAE,WAIMK,EAAkC,GAClCC,EAA6B,OAEC,cALpCN,EAAUA,GAAW,aAKRqC,oBAA8B,KACnCC,EACJtC,EAAQsC,yBAA2BhD,EAErCQ,EACGI,mBACAqC,SACAhC,SAAQ,SAAAhB,GACH+C,EAAwB/C,IAC1Bc,EAAUmC,KA7CpB,SAA2BjD,SAClB,CACLqB,YAAarB,EAASS,QAAQY,YAC9BpB,MAAOD,EAASC,OA0CKiD,CAAkBlD,WAKP,cAA9BS,YAAS0C,kBAA4B,KACjCC,EACJ3C,EAAQ2C,sBAAwBjD,EAElCI,EACGM,gBACAmC,SACAhC,SAAQ,SAAAZ,GACHgD,EAAqBhD,IACvBW,EAAQkC,KAhDlB,SAAwB7C,SACf,CACLH,MAAOG,EAAMH,MACb2B,SAAUxB,EAAMwB,SAChBJ,UAAWpB,EAAMoB,WA4CE6B,CAAejD,aAK7B,CAAEU,UAAAA,EAAWC,QAAAA"}